//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IAccountClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    register(body?: RegisterDto | undefined): Promise<UserDto>;
    /**
     * @param body (optional) 
     * @return Success
     */
    login(body?: LoginDto | undefined): Promise<UserDto>;
    /**
     * @return Success
     */
    refreshToken(): Promise<UserDto>;
}

export class AccountClient implements IAccountClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body?: RegisterDto | undefined, cancelToken?: CancelToken): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/Account/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body?: LoginDto | undefined, cancelToken?: CancelToken): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/Account/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @return Success
     */
    refreshToken( cancelToken?: CancelToken): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/Account/refreshToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefreshToken(_response);
        });
    }

    protected processRefreshToken(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }
}

export interface IAuthClient {
    /**
     * @return Success
     */
    deviceCode(): Promise<DeviceCode>;
    /**
     * @param body (optional) 
     * @return Success
     */
    poll(body?: PollingRequest | undefined): Promise<PollingResponse>;
    verify(body?: VerifyCodeRequest | undefined): Promise<void>;
}

export class AuthClient implements IAuthClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return Success
     */
    deviceCode( cancelToken?: CancelToken): Promise<DeviceCode> {
        let url_ = this.baseUrl + "/api/Auth/device-code";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeviceCode(_response);
        });
    }

    protected processDeviceCode(response: AxiosResponse): Promise<DeviceCode> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DeviceCode.fromJS(resultData200);
            return Promise.resolve<DeviceCode>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceCode>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    poll(body?: PollingRequest | undefined, cancelToken?: CancelToken): Promise<PollingResponse> {
        let url_ = this.baseUrl + "/api/Auth/poll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPoll(_response);
        });
    }

    protected processPoll(response: AxiosResponse): Promise<PollingResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PollingResponse.fromJS(resultData200);
            return Promise.resolve<PollingResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PollingResponse>(null as any);
    }

    verify(body?: VerifyCodeRequest | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/verify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerify(_response);
        });
    }

    protected processVerify(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IMenuClient {
    /**
     * @return Success
     */
    menuAll(): Promise<MenuDto[]>;
    /**
     * @param name (optional) 
     * @param restaurantId (optional) 
     * @return Success
     */
    menuPOST(name?: string | undefined, restaurantId?: number | undefined): Promise<MenuDto>;
    /**
     * @return Success
     */
    menuGET(id: number): Promise<MenuDto>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    menuPUT(id: number, body?: MenuDto | undefined): Promise<void>;
    /**
     * @return No Content
     */
    menuDELETE(id: number): Promise<void>;
    /**
     * @param file (optional) 
     * @return Success
     */
    boardPhoto(id: number, file?: FileParameter | undefined): Promise<BoardPhoto>;
}

export class MenuClient implements IMenuClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return Success
     */
    menuAll( cancelToken?: CancelToken): Promise<MenuDto[]> {
        let url_ = this.baseUrl + "/api/Menu";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuAll(_response);
        });
    }

    protected processMenuAll(response: AxiosResponse): Promise<MenuDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MenuDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MenuDto[]>(null as any);
    }

    /**
     * @param name (optional) 
     * @param restaurantId (optional) 
     * @return Success
     */
    menuPOST(name?: string | undefined, restaurantId?: number | undefined, cancelToken?: CancelToken): Promise<MenuDto> {
        let url_ = this.baseUrl + "/api/Menu?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (restaurantId === null)
            throw new Error("The parameter 'restaurantId' cannot be null.");
        else if (restaurantId !== undefined)
            url_ += "restaurantId=" + encodeURIComponent("" + restaurantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuPOST(_response);
        });
    }

    protected processMenuPOST(response: AxiosResponse): Promise<MenuDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MenuDto.fromJS(resultData200);
            return Promise.resolve<MenuDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MenuDto>(null as any);
    }

    /**
     * @return Success
     */
    menuGET(id: number, cancelToken?: CancelToken): Promise<MenuDto> {
        let url_ = this.baseUrl + "/api/Menu/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuGET(_response);
        });
    }

    protected processMenuGET(response: AxiosResponse): Promise<MenuDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MenuDto.fromJS(resultData200);
            return Promise.resolve<MenuDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MenuDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    menuPUT(id: number, body?: MenuDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Menu/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuPUT(_response);
        });
    }

    protected processMenuPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    menuDELETE(id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Menu/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuDELETE(_response);
        });
    }

    protected processMenuDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    boardPhoto(id: number, file?: FileParameter | undefined, cancelToken?: CancelToken): Promise<BoardPhoto> {
        let url_ = this.baseUrl + "/api/Menu/{id}/board-photo";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBoardPhoto(_response);
        });
    }

    protected processBoardPhoto(response: AxiosResponse): Promise<BoardPhoto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BoardPhoto.fromJS(resultData200);
            return Promise.resolve<BoardPhoto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BoardPhoto>(null as any);
    }
}

export interface IMenuItemsClient {
    /**
     * @return Success
     */
    menuSection(menuSectionId: number): Promise<MenuItemDto[]>;
    /**
     * @return Success
     */
    menuItemsGET(id: number): Promise<MenuItemDto>;
    menuItemsPUT(id: number, body?: MenuItemDto | undefined): Promise<void>;
    /**
     * @return No Content
     */
    menuItemsDELETE(id: number): Promise<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    menuItemsPOST(body?: MenuItemDto | undefined): Promise<MenuItemDto>;
}

export class MenuItemsClient implements IMenuItemsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return Success
     */
    menuSection(menuSectionId: number, cancelToken?: CancelToken): Promise<MenuItemDto[]> {
        let url_ = this.baseUrl + "/api/MenuItems/menuSection/{menuSectionId}";
        if (menuSectionId === undefined || menuSectionId === null)
            throw new Error("The parameter 'menuSectionId' must be defined.");
        url_ = url_.replace("{menuSectionId}", encodeURIComponent("" + menuSectionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuSection(_response);
        });
    }

    protected processMenuSection(response: AxiosResponse): Promise<MenuItemDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MenuItemDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MenuItemDto[]>(null as any);
    }

    /**
     * @return Success
     */
    menuItemsGET(id: number, cancelToken?: CancelToken): Promise<MenuItemDto> {
        let url_ = this.baseUrl + "/api/MenuItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuItemsGET(_response);
        });
    }

    protected processMenuItemsGET(response: AxiosResponse): Promise<MenuItemDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MenuItemDto.fromJS(resultData200);
            return Promise.resolve<MenuItemDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MenuItemDto>(null as any);
    }

    menuItemsPUT(id: number, body?: MenuItemDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/MenuItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuItemsPUT(_response);
        });
    }

    protected processMenuItemsPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    menuItemsDELETE(id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/MenuItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuItemsDELETE(_response);
        });
    }

    protected processMenuItemsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    menuItemsPOST(body?: MenuItemDto | undefined, cancelToken?: CancelToken): Promise<MenuItemDto> {
        let url_ = this.baseUrl + "/api/MenuItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuItemsPOST(_response);
        });
    }

    protected processMenuItemsPOST(response: AxiosResponse): Promise<MenuItemDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MenuItemDto.fromJS(resultData200);
            return Promise.resolve<MenuItemDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MenuItemDto>(null as any);
    }
}

export interface IMenuSectionClient {
    /**
     * @return Success
     */
    admin(menuId: number): Promise<MenuSectionDto[]>;
    /**
     * @param menuId (optional) 
     * @param sectionName (optional) 
     * @return Success
     */
    menuSectionPOST(menuId?: number | undefined, sectionName?: string | undefined): Promise<MenuSectionDto>;
    /**
     * @param menuId (optional) 
     * @param menuSectionId (optional) 
     * @param sectionName (optional) 
     * @return Success
     */
    menuSectionPATCH(menuId?: number | undefined, menuSectionId?: number | undefined, sectionName?: string | undefined): Promise<MenuSectionDto>;
    menuSectionDELETE(id: number): Promise<void>;
}

export class MenuSectionClient implements IMenuSectionClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return Success
     */
    admin(menuId: number, cancelToken?: CancelToken): Promise<MenuSectionDto[]> {
        let url_ = this.baseUrl + "/api/MenuSection/admin/{menuId}";
        if (menuId === undefined || menuId === null)
            throw new Error("The parameter 'menuId' must be defined.");
        url_ = url_.replace("{menuId}", encodeURIComponent("" + menuId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdmin(_response);
        });
    }

    protected processAdmin(response: AxiosResponse): Promise<MenuSectionDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuSectionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MenuSectionDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MenuSectionDto[]>(null as any);
    }

    /**
     * @param menuId (optional) 
     * @param sectionName (optional) 
     * @return Success
     */
    menuSectionPOST(menuId?: number | undefined, sectionName?: string | undefined, cancelToken?: CancelToken): Promise<MenuSectionDto> {
        let url_ = this.baseUrl + "/api/MenuSection?";
        if (menuId === null)
            throw new Error("The parameter 'menuId' cannot be null.");
        else if (menuId !== undefined)
            url_ += "menuId=" + encodeURIComponent("" + menuId) + "&";
        if (sectionName === null)
            throw new Error("The parameter 'sectionName' cannot be null.");
        else if (sectionName !== undefined)
            url_ += "sectionName=" + encodeURIComponent("" + sectionName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuSectionPOST(_response);
        });
    }

    protected processMenuSectionPOST(response: AxiosResponse): Promise<MenuSectionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MenuSectionDto.fromJS(resultData200);
            return Promise.resolve<MenuSectionDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MenuSectionDto>(null as any);
    }

    /**
     * @param menuId (optional) 
     * @param menuSectionId (optional) 
     * @param sectionName (optional) 
     * @return Success
     */
    menuSectionPATCH(menuId?: number | undefined, menuSectionId?: number | undefined, sectionName?: string | undefined, cancelToken?: CancelToken): Promise<MenuSectionDto> {
        let url_ = this.baseUrl + "/api/MenuSection?";
        if (menuId === null)
            throw new Error("The parameter 'menuId' cannot be null.");
        else if (menuId !== undefined)
            url_ += "menuId=" + encodeURIComponent("" + menuId) + "&";
        if (menuSectionId === null)
            throw new Error("The parameter 'menuSectionId' cannot be null.");
        else if (menuSectionId !== undefined)
            url_ += "menuSectionId=" + encodeURIComponent("" + menuSectionId) + "&";
        if (sectionName === null)
            throw new Error("The parameter 'sectionName' cannot be null.");
        else if (sectionName !== undefined)
            url_ += "sectionName=" + encodeURIComponent("" + sectionName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PATCH",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuSectionPATCH(_response);
        });
    }

    protected processMenuSectionPATCH(response: AxiosResponse): Promise<MenuSectionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MenuSectionDto.fromJS(resultData200);
            return Promise.resolve<MenuSectionDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MenuSectionDto>(null as any);
    }

    menuSectionDELETE(id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/MenuSection/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuSectionDELETE(_response);
        });
    }

    protected processMenuSectionDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IRestaurantClient {
    /**
     * @return Success
     */
    restaurantAll(): Promise<RestaurantDto[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    restaurantPOST(body?: Restaurant | undefined): Promise<RestaurantDto>;
    /**
     * @param body (optional) 
     * @return Success
     */
    restaurantPUT(body?: RestaurantDto | undefined): Promise<RestaurantDto>;
    /**
     * @return Success
     */
    restaurantGET(id: number): Promise<RestaurantDto>;
    restaurantDELETE(id: number): Promise<void>;
}

export class RestaurantClient implements IRestaurantClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return Success
     */
    restaurantAll( cancelToken?: CancelToken): Promise<RestaurantDto[]> {
        let url_ = this.baseUrl + "/api/Restaurant";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantAll(_response);
        });
    }

    protected processRestaurantAll(response: AxiosResponse): Promise<RestaurantDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RestaurantDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RestaurantDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RestaurantDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    restaurantPOST(body?: Restaurant | undefined, cancelToken?: CancelToken): Promise<RestaurantDto> {
        let url_ = this.baseUrl + "/api/Restaurant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantPOST(_response);
        });
    }

    protected processRestaurantPOST(response: AxiosResponse): Promise<RestaurantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RestaurantDto.fromJS(resultData200);
            return Promise.resolve<RestaurantDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RestaurantDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    restaurantPUT(body?: RestaurantDto | undefined, cancelToken?: CancelToken): Promise<RestaurantDto> {
        let url_ = this.baseUrl + "/api/Restaurant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantPUT(_response);
        });
    }

    protected processRestaurantPUT(response: AxiosResponse): Promise<RestaurantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RestaurantDto.fromJS(resultData200);
            return Promise.resolve<RestaurantDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RestaurantDto>(null as any);
    }

    /**
     * @return Success
     */
    restaurantGET(id: number, cancelToken?: CancelToken): Promise<RestaurantDto> {
        let url_ = this.baseUrl + "/api/Restaurant/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantGET(_response);
        });
    }

    protected processRestaurantGET(response: AxiosResponse): Promise<RestaurantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RestaurantDto.fromJS(resultData200);
            return Promise.resolve<RestaurantDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RestaurantDto>(null as any);
    }

    restaurantDELETE(id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Restaurant/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantDELETE(_response);
        });
    }

    protected processRestaurantDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class BoardPhoto implements IBoardPhoto {
    id?: number;
    url?: string | null;
    publicId?: string | null;

    constructor(data?: IBoardPhoto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.url = _data["url"] !== undefined ? _data["url"] : <any>null;
            this.publicId = _data["publicId"] !== undefined ? _data["publicId"] : <any>null;
        }
    }

    static fromJS(data: any): BoardPhoto {
        data = typeof data === 'object' ? data : {};
        let result = new BoardPhoto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        data["publicId"] = this.publicId !== undefined ? this.publicId : <any>null;
        return data;
    }
}

export interface IBoardPhoto {
    id?: number;
    url?: string | null;
    publicId?: string | null;
}

export class DeviceCode implements IDeviceCode {
    code?: string | null;
    pollingToken?: string | null;
    timeStamp?: Date;
    userId?: string | null;
    expirationInSeconds?: number;

    constructor(data?: IDeviceCode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.pollingToken = _data["pollingToken"] !== undefined ? _data["pollingToken"] : <any>null;
            this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.expirationInSeconds = _data["expirationInSeconds"] !== undefined ? _data["expirationInSeconds"] : <any>null;
        }
    }

    static fromJS(data: any): DeviceCode {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["pollingToken"] = this.pollingToken !== undefined ? this.pollingToken : <any>null;
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["expirationInSeconds"] = this.expirationInSeconds !== undefined ? this.expirationInSeconds : <any>null;
        return data;
    }
}

export interface IDeviceCode {
    code?: string | null;
    pollingToken?: string | null;
    timeStamp?: Date;
    userId?: string | null;
    expirationInSeconds?: number;
}

export class LoginDto implements ILoginDto {
    username!: string;
    password!: string;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface ILoginDto {
    username: string;
    password: string;
}

export class Menu implements IMenu {
    id?: number;
    name?: string | null;
    publicUrl?: string | null;
    menuSections?: MenuSection[] | null;
    boardPhoto?: BoardPhoto;
    appUserId?: number;
    restaurantId?: number;

    constructor(data?: IMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.menuSections) {
                this.menuSections = [];
                for (let i = 0; i < data.menuSections.length; i++) {
                    let item = data.menuSections[i];
                    this.menuSections[i] = item && !(<any>item).toJSON ? new MenuSection(item) : <MenuSection>item;
                }
            }
            this.boardPhoto = data.boardPhoto && !(<any>data.boardPhoto).toJSON ? new BoardPhoto(data.boardPhoto) : <BoardPhoto>this.boardPhoto;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.publicUrl = _data["publicUrl"] !== undefined ? _data["publicUrl"] : <any>null;
            if (Array.isArray(_data["menuSections"])) {
                this.menuSections = [] as any;
                for (let item of _data["menuSections"])
                    this.menuSections!.push(MenuSection.fromJS(item));
            }
            else {
                this.menuSections = <any>null;
            }
            this.boardPhoto = _data["boardPhoto"] ? BoardPhoto.fromJS(_data["boardPhoto"]) : <any>null;
            this.appUserId = _data["appUserId"] !== undefined ? _data["appUserId"] : <any>null;
            this.restaurantId = _data["restaurantId"] !== undefined ? _data["restaurantId"] : <any>null;
        }
    }

    static fromJS(data: any): Menu {
        data = typeof data === 'object' ? data : {};
        let result = new Menu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["publicUrl"] = this.publicUrl !== undefined ? this.publicUrl : <any>null;
        if (Array.isArray(this.menuSections)) {
            data["menuSections"] = [];
            for (let item of this.menuSections)
                data["menuSections"].push(item.toJSON());
        }
        data["boardPhoto"] = this.boardPhoto ? this.boardPhoto.toJSON() : <any>null;
        data["appUserId"] = this.appUserId !== undefined ? this.appUserId : <any>null;
        data["restaurantId"] = this.restaurantId !== undefined ? this.restaurantId : <any>null;
        return data;
    }
}

export interface IMenu {
    id?: number;
    name?: string | null;
    publicUrl?: string | null;
    menuSections?: IMenuSection[] | null;
    boardPhoto?: IBoardPhoto;
    appUserId?: number;
    restaurantId?: number;
}

export class MenuDto implements IMenuDto {
    id?: number;
    name?: string | null;
    publicUrl?: string | null;
    menuSections?: MenuSectionDto[] | null;

    constructor(data?: IMenuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.menuSections) {
                this.menuSections = [];
                for (let i = 0; i < data.menuSections.length; i++) {
                    let item = data.menuSections[i];
                    this.menuSections[i] = item && !(<any>item).toJSON ? new MenuSectionDto(item) : <MenuSectionDto>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.publicUrl = _data["publicUrl"] !== undefined ? _data["publicUrl"] : <any>null;
            if (Array.isArray(_data["menuSections"])) {
                this.menuSections = [] as any;
                for (let item of _data["menuSections"])
                    this.menuSections!.push(MenuSectionDto.fromJS(item));
            }
            else {
                this.menuSections = <any>null;
            }
        }
    }

    static fromJS(data: any): MenuDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["publicUrl"] = this.publicUrl !== undefined ? this.publicUrl : <any>null;
        if (Array.isArray(this.menuSections)) {
            data["menuSections"] = [];
            for (let item of this.menuSections)
                data["menuSections"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMenuDto {
    id?: number;
    name?: string | null;
    publicUrl?: string | null;
    menuSections?: IMenuSectionDto[] | null;
}

export class MenuItem implements IMenuItem {
    id?: number;
    menuSectionId?: number;
    name?: string | null;
    description?: string | null;
    price?: number;

    constructor(data?: IMenuItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.menuSectionId = _data["menuSectionId"] !== undefined ? _data["menuSectionId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
        }
    }

    static fromJS(data: any): MenuItem {
        data = typeof data === 'object' ? data : {};
        let result = new MenuItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["menuSectionId"] = this.menuSectionId !== undefined ? this.menuSectionId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        return data;
    }
}

export interface IMenuItem {
    id?: number;
    menuSectionId?: number;
    name?: string | null;
    description?: string | null;
    price?: number;
}

export class MenuItemDto implements IMenuItemDto {
    id?: number;
    name?: string | null;
    description?: string | null;
    price?: number;
    menuSectionId?: number;

    constructor(data?: IMenuItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
            this.menuSectionId = _data["menuSectionId"] !== undefined ? _data["menuSectionId"] : <any>null;
        }
    }

    static fromJS(data: any): MenuItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["menuSectionId"] = this.menuSectionId !== undefined ? this.menuSectionId : <any>null;
        return data;
    }
}

export interface IMenuItemDto {
    id?: number;
    name?: string | null;
    description?: string | null;
    price?: number;
    menuSectionId?: number;
}

export class MenuSection implements IMenuSection {
    id?: number;
    menuId?: number;
    name?: string | null;
    menuItems?: MenuItem[] | null;

    constructor(data?: IMenuSection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.menuItems) {
                this.menuItems = [];
                for (let i = 0; i < data.menuItems.length; i++) {
                    let item = data.menuItems[i];
                    this.menuItems[i] = item && !(<any>item).toJSON ? new MenuItem(item) : <MenuItem>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.menuId = _data["menuId"] !== undefined ? _data["menuId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["menuItems"])) {
                this.menuItems = [] as any;
                for (let item of _data["menuItems"])
                    this.menuItems!.push(MenuItem.fromJS(item));
            }
            else {
                this.menuItems = <any>null;
            }
        }
    }

    static fromJS(data: any): MenuSection {
        data = typeof data === 'object' ? data : {};
        let result = new MenuSection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["menuId"] = this.menuId !== undefined ? this.menuId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.menuItems)) {
            data["menuItems"] = [];
            for (let item of this.menuItems)
                data["menuItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMenuSection {
    id?: number;
    menuId?: number;
    name?: string | null;
    menuItems?: IMenuItem[] | null;
}

export class MenuSectionDto implements IMenuSectionDto {
    id?: number;
    name?: string | null;
    readonly menuItemsCount?: number;
    menuItems?: MenuItemDto[] | null;

    constructor(data?: IMenuSectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.menuItems) {
                this.menuItems = [];
                for (let i = 0; i < data.menuItems.length; i++) {
                    let item = data.menuItems[i];
                    this.menuItems[i] = item && !(<any>item).toJSON ? new MenuItemDto(item) : <MenuItemDto>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            (<any>this).menuItemsCount = _data["menuItemsCount"] !== undefined ? _data["menuItemsCount"] : <any>null;
            if (Array.isArray(_data["menuItems"])) {
                this.menuItems = [] as any;
                for (let item of _data["menuItems"])
                    this.menuItems!.push(MenuItemDto.fromJS(item));
            }
            else {
                this.menuItems = <any>null;
            }
        }
    }

    static fromJS(data: any): MenuSectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuSectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["menuItemsCount"] = this.menuItemsCount !== undefined ? this.menuItemsCount : <any>null;
        if (Array.isArray(this.menuItems)) {
            data["menuItems"] = [];
            for (let item of this.menuItems)
                data["menuItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMenuSectionDto {
    id?: number;
    name?: string | null;
    menuItemsCount?: number;
    menuItems?: IMenuItemDto[] | null;
}

export class PollingRequest implements IPollingRequest {
    pollingToken?: string | null;

    constructor(data?: IPollingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pollingToken = _data["pollingToken"] !== undefined ? _data["pollingToken"] : <any>null;
        }
    }

    static fromJS(data: any): PollingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PollingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pollingToken"] = this.pollingToken !== undefined ? this.pollingToken : <any>null;
        return data;
    }
}

export interface IPollingRequest {
    pollingToken?: string | null;
}

export class PollingResponse implements IPollingResponse {
    user?: UserDto;
    isAuthenticated?: boolean;

    constructor(data?: IPollingResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.user = data.user && !(<any>data.user).toJSON ? new UserDto(data.user) : <UserDto>this.user;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>null;
            this.isAuthenticated = _data["isAuthenticated"] !== undefined ? _data["isAuthenticated"] : <any>null;
        }
    }

    static fromJS(data: any): PollingResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PollingResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        data["isAuthenticated"] = this.isAuthenticated !== undefined ? this.isAuthenticated : <any>null;
        return data;
    }
}

export interface IPollingResponse {
    user?: IUserDto;
    isAuthenticated?: boolean;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.detail = _data["detail"] !== undefined ? _data["detail"] : <any>null;
            this.instance = _data["instance"] !== undefined ? _data["instance"] : <any>null;
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["detail"] = this.detail !== undefined ? this.detail : <any>null;
        data["instance"] = this.instance !== undefined ? this.instance : <any>null;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;

    [key: string]: any;
}

export class RegisterDto implements IRegisterDto {
    username!: string;
    password!: string;

    constructor(data?: IRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): RegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface IRegisterDto {
    username: string;
    password: string;
}

export class Restaurant implements IRestaurant {
    id?: number;
    name?: string | null;
    phone?: string | null;
    address?: string | null;
    appUserId?: number;
    menus?: Menu[] | null;

    constructor(data?: IRestaurant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.menus) {
                this.menus = [];
                for (let i = 0; i < data.menus.length; i++) {
                    let item = data.menus[i];
                    this.menus[i] = item && !(<any>item).toJSON ? new Menu(item) : <Menu>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.phone = _data["phone"] !== undefined ? _data["phone"] : <any>null;
            this.address = _data["address"] !== undefined ? _data["address"] : <any>null;
            this.appUserId = _data["appUserId"] !== undefined ? _data["appUserId"] : <any>null;
            if (Array.isArray(_data["menus"])) {
                this.menus = [] as any;
                for (let item of _data["menus"])
                    this.menus!.push(Menu.fromJS(item));
            }
            else {
                this.menus = <any>null;
            }
        }
    }

    static fromJS(data: any): Restaurant {
        data = typeof data === 'object' ? data : {};
        let result = new Restaurant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["appUserId"] = this.appUserId !== undefined ? this.appUserId : <any>null;
        if (Array.isArray(this.menus)) {
            data["menus"] = [];
            for (let item of this.menus)
                data["menus"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRestaurant {
    id?: number;
    name?: string | null;
    phone?: string | null;
    address?: string | null;
    appUserId?: number;
    menus?: IMenu[] | null;
}

export class RestaurantDto implements IRestaurantDto {
    id?: number;
    name?: string | null;
    menuCount?: number;
    menus?: MenuDto[] | null;

    constructor(data?: IRestaurantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.menus) {
                this.menus = [];
                for (let i = 0; i < data.menus.length; i++) {
                    let item = data.menus[i];
                    this.menus[i] = item && !(<any>item).toJSON ? new MenuDto(item) : <MenuDto>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.menuCount = _data["menuCount"] !== undefined ? _data["menuCount"] : <any>null;
            if (Array.isArray(_data["menus"])) {
                this.menus = [] as any;
                for (let item of _data["menus"])
                    this.menus!.push(MenuDto.fromJS(item));
            }
            else {
                this.menus = <any>null;
            }
        }
    }

    static fromJS(data: any): RestaurantDto {
        data = typeof data === 'object' ? data : {};
        let result = new RestaurantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["menuCount"] = this.menuCount !== undefined ? this.menuCount : <any>null;
        if (Array.isArray(this.menus)) {
            data["menus"] = [];
            for (let item of this.menus)
                data["menus"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRestaurantDto {
    id?: number;
    name?: string | null;
    menuCount?: number;
    menus?: IMenuDto[] | null;
}

export class UserDto implements IUserDto {
    id?: number;
    username?: string | null;
    email?: string | null;
    token?: string | null;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["token"] = this.token !== undefined ? this.token : <any>null;
        return data;
    }
}

export interface IUserDto {
    id?: number;
    username?: string | null;
    email?: string | null;
    token?: string | null;
}

export class ValidationProblemDetails implements IValidationProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;
    errors?: { [key: string]: string[]; } | null;

    [key: string]: any;

    constructor(data?: IValidationProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.detail = _data["detail"] !== undefined ? _data["detail"] : <any>null;
            this.instance = _data["instance"] !== undefined ? _data["instance"] : <any>null;
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
            else {
                this.errors = <any>null;
            }
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["detail"] = this.detail !== undefined ? this.detail : <any>null;
        data["instance"] = this.instance !== undefined ? this.instance : <any>null;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = this.errors[key] !== undefined ? this.errors[key] : <any>null;
            }
        }
        return data;
    }
}

export interface IValidationProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;
    errors?: { [key: string]: string[]; } | null;

    [key: string]: any;
}

export class VerifyCodeRequest implements IVerifyCodeRequest {
    code?: string | null;

    constructor(data?: IVerifyCodeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
        }
    }

    static fromJS(data: any): VerifyCodeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyCodeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        return data;
    }
}

export interface IVerifyCodeRequest {
    code?: string | null;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ClientApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isClientApiException = true;

    static isClientApiException(obj: any): obj is ClientApiException {
        return obj.isClientApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ClientApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}